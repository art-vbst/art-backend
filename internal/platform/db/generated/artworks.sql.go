// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: artworks.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createArtwork = `-- name: CreateArtwork :one
INSERT INTO artworks (
        title,
        painting_number,
        painting_year,
        width_inches,
        height_inches,
        price_cents,
        paper,
        status,
        medium,
        category
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10
    )
RETURNING id, title, painting_number, painting_year, width_inches, height_inches, price_cents, paper, sort_order, sold_at, status, medium, category, created_at, order_id
`

type CreateArtworkParams struct {
	Title          string          `db:"title" json:"title"`
	PaintingNumber *int32          `db:"painting_number" json:"painting_number"`
	PaintingYear   *int32          `db:"painting_year" json:"painting_year"`
	WidthInches    pgtype.Numeric  `db:"width_inches" json:"width_inches"`
	HeightInches   pgtype.Numeric  `db:"height_inches" json:"height_inches"`
	PriceCents     int32           `db:"price_cents" json:"price_cents"`
	Paper          *bool           `db:"paper" json:"paper"`
	Status         ArtworkStatus   `db:"status" json:"status"`
	Medium         ArtworkMedium   `db:"medium" json:"medium"`
	Category       ArtworkCategory `db:"category" json:"category"`
}

func (q *Queries) CreateArtwork(ctx context.Context, arg CreateArtworkParams) (Artwork, error) {
	row := q.db.QueryRow(ctx, createArtwork,
		arg.Title,
		arg.PaintingNumber,
		arg.PaintingYear,
		arg.WidthInches,
		arg.HeightInches,
		arg.PriceCents,
		arg.Paper,
		arg.Status,
		arg.Medium,
		arg.Category,
	)
	var i Artwork
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.PaintingNumber,
		&i.PaintingYear,
		&i.WidthInches,
		&i.HeightInches,
		&i.PriceCents,
		&i.Paper,
		&i.SortOrder,
		&i.SoldAt,
		&i.Status,
		&i.Medium,
		&i.Category,
		&i.CreatedAt,
		&i.OrderID,
	)
	return i, err
}

const deleteArtwork = `-- name: DeleteArtwork :exec
DELETE FROM artworks
WHERE id = $1
`

func (q *Queries) DeleteArtwork(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteArtwork, id)
	return err
}

const getArtworkWithImages = `-- name: GetArtworkWithImages :many
SELECT a.id, a.title, a.painting_number, a.painting_year, a.width_inches, a.height_inches, a.price_cents, a.paper, a.sort_order, a.sold_at, a.status, a.medium, a.category, a.created_at, a.order_id,
    i.id as image_id,
    i.is_main_image,
    i.object_name,
    i.image_url,
    i.image_width,
    i.image_height,
    i.created_at as image_created_at
FROM artworks a
    LEFT JOIN images i ON a.id = i.artwork_id
WHERE a.id = $1
ORDER BY i.created_at
`

type GetArtworkWithImagesRow struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	Title          string           `db:"title" json:"title"`
	PaintingNumber *int32           `db:"painting_number" json:"painting_number"`
	PaintingYear   *int32           `db:"painting_year" json:"painting_year"`
	WidthInches    pgtype.Numeric   `db:"width_inches" json:"width_inches"`
	HeightInches   pgtype.Numeric   `db:"height_inches" json:"height_inches"`
	PriceCents     int32            `db:"price_cents" json:"price_cents"`
	Paper          *bool            `db:"paper" json:"paper"`
	SortOrder      int32            `db:"sort_order" json:"sort_order"`
	SoldAt         pgtype.Timestamp `db:"sold_at" json:"sold_at"`
	Status         ArtworkStatus    `db:"status" json:"status"`
	Medium         ArtworkMedium    `db:"medium" json:"medium"`
	Category       ArtworkCategory  `db:"category" json:"category"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	OrderID        pgtype.UUID      `db:"order_id" json:"order_id"`
	ImageID        pgtype.UUID      `db:"image_id" json:"image_id"`
	IsMainImage    *bool            `db:"is_main_image" json:"is_main_image"`
	ObjectName     *string          `db:"object_name" json:"object_name"`
	ImageUrl       *string          `db:"image_url" json:"image_url"`
	ImageWidth     *int32           `db:"image_width" json:"image_width"`
	ImageHeight    *int32           `db:"image_height" json:"image_height"`
	ImageCreatedAt pgtype.Timestamp `db:"image_created_at" json:"image_created_at"`
}

func (q *Queries) GetArtworkWithImages(ctx context.Context, id uuid.UUID) ([]GetArtworkWithImagesRow, error) {
	rows, err := q.db.Query(ctx, getArtworkWithImages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArtworkWithImagesRow
	for rows.Next() {
		var i GetArtworkWithImagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PaintingNumber,
			&i.PaintingYear,
			&i.WidthInches,
			&i.HeightInches,
			&i.PriceCents,
			&i.Paper,
			&i.SortOrder,
			&i.SoldAt,
			&i.Status,
			&i.Medium,
			&i.Category,
			&i.CreatedAt,
			&i.OrderID,
			&i.ImageID,
			&i.IsMainImage,
			&i.ObjectName,
			&i.ImageUrl,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.ImageCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArtworkStripeData = `-- name: ListArtworkStripeData :many
SELECT a.id,
    a.title,
    a.price_cents,
    a.status,
    i.image_id, i.image_url
FROM artworks a
    LEFT JOIN LATERAL (
        SELECT id as image_id,
            image_url
        FROM images
        WHERE artwork_id = a.id
        ORDER BY is_main_image DESC NULLS LAST,
            created_at
        LIMIT 1
    ) i ON true
WHERE a.id = ANY($1::uuid [])
    AND a.status = 'available'
`

type ListArtworkStripeDataRow struct {
	ID         uuid.UUID     `db:"id" json:"id"`
	Title      string        `db:"title" json:"title"`
	PriceCents int32         `db:"price_cents" json:"price_cents"`
	Status     ArtworkStatus `db:"status" json:"status"`
	ImageID    uuid.UUID     `db:"image_id" json:"image_id"`
	ImageUrl   string        `db:"image_url" json:"image_url"`
}

func (q *Queries) ListArtworkStripeData(ctx context.Context, dollar_1 []uuid.UUID) ([]ListArtworkStripeDataRow, error) {
	rows, err := q.db.Query(ctx, listArtworkStripeData, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListArtworkStripeDataRow
	for rows.Next() {
		var i ListArtworkStripeDataRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PriceCents,
			&i.Status,
			&i.ImageID,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listArtworks = `-- name: ListArtworks :many
SELECT a.id, a.title, a.painting_number, a.painting_year, a.width_inches, a.height_inches, a.price_cents, a.paper, a.sort_order, a.sold_at, a.status, a.medium, a.category, a.created_at, a.order_id,
    i.image_id,
    COALESCE(i.object_name, '') as object_name,
    COALESCE(i.image_url, '') as image_url,
    i.image_width,
    i.image_height,
    i.image_created_at
FROM artworks a
    LEFT JOIN LATERAL (
        SELECT id as image_id,
            object_name,
            image_url,
            image_width,
            image_height,
            created_at as image_created_at
        FROM images
        WHERE artwork_id = a.id
        ORDER BY is_main_image DESC NULLS LAST,
            created_at
        LIMIT 1
    ) i ON true
WHERE $1::text [] IS NULL
    OR cardinality($1) = 0
    OR a.status = ANY($1::artwork_status [])
ORDER BY a.sort_order,
    a.created_at DESC
`

type ListArtworksRow struct {
	ID             uuid.UUID        `db:"id" json:"id"`
	Title          string           `db:"title" json:"title"`
	PaintingNumber *int32           `db:"painting_number" json:"painting_number"`
	PaintingYear   *int32           `db:"painting_year" json:"painting_year"`
	WidthInches    pgtype.Numeric   `db:"width_inches" json:"width_inches"`
	HeightInches   pgtype.Numeric   `db:"height_inches" json:"height_inches"`
	PriceCents     int32            `db:"price_cents" json:"price_cents"`
	Paper          *bool            `db:"paper" json:"paper"`
	SortOrder      int32            `db:"sort_order" json:"sort_order"`
	SoldAt         pgtype.Timestamp `db:"sold_at" json:"sold_at"`
	Status         ArtworkStatus    `db:"status" json:"status"`
	Medium         ArtworkMedium    `db:"medium" json:"medium"`
	Category       ArtworkCategory  `db:"category" json:"category"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	OrderID        pgtype.UUID      `db:"order_id" json:"order_id"`
	ImageID        uuid.UUID        `db:"image_id" json:"image_id"`
	ObjectName     string           `db:"object_name" json:"object_name"`
	ImageUrl       string           `db:"image_url" json:"image_url"`
	ImageWidth     *int32           `db:"image_width" json:"image_width"`
	ImageHeight    *int32           `db:"image_height" json:"image_height"`
	ImageCreatedAt pgtype.Timestamp `db:"image_created_at" json:"image_created_at"`
}

func (q *Queries) ListArtworks(ctx context.Context, dollar_1 []string) ([]ListArtworksRow, error) {
	rows, err := q.db.Query(ctx, listArtworks, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListArtworksRow
	for rows.Next() {
		var i ListArtworksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PaintingNumber,
			&i.PaintingYear,
			&i.WidthInches,
			&i.HeightInches,
			&i.PriceCents,
			&i.Paper,
			&i.SortOrder,
			&i.SoldAt,
			&i.Status,
			&i.Medium,
			&i.Category,
			&i.CreatedAt,
			&i.OrderID,
			&i.ImageID,
			&i.ObjectName,
			&i.ImageUrl,
			&i.ImageWidth,
			&i.ImageHeight,
			&i.ImageCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectArtworksForUpdate = `-- name: SelectArtworksForUpdate :many
SELECT id, title, painting_number, painting_year, width_inches, height_inches, price_cents, paper, sort_order, sold_at, status, medium, category, created_at, order_id
FROM artworks
WHERE id = ANY($1::uuid [])
    AND status = 'available' FOR
UPDATE
`

func (q *Queries) SelectArtworksForUpdate(ctx context.Context, dollar_1 []uuid.UUID) ([]Artwork, error) {
	rows, err := q.db.Query(ctx, selectArtworksForUpdate, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artwork
	for rows.Next() {
		var i Artwork
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PaintingNumber,
			&i.PaintingYear,
			&i.WidthInches,
			&i.HeightInches,
			&i.PriceCents,
			&i.Paper,
			&i.SortOrder,
			&i.SoldAt,
			&i.Status,
			&i.Medium,
			&i.Category,
			&i.CreatedAt,
			&i.OrderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateArtwork = `-- name: UpdateArtwork :one
UPDATE artworks
SET title = $2,
    painting_number = $3,
    painting_year = $4,
    width_inches = $5,
    height_inches = $6,
    price_cents = $7,
    paper = $8,
    sort_order = $9,
    status = $10,
    medium = $11,
    category = $12
WHERE id = $1
RETURNING id, title, painting_number, painting_year, width_inches, height_inches, price_cents, paper, sort_order, sold_at, status, medium, category, created_at, order_id
`

type UpdateArtworkParams struct {
	ID             uuid.UUID       `db:"id" json:"id"`
	Title          string          `db:"title" json:"title"`
	PaintingNumber *int32          `db:"painting_number" json:"painting_number"`
	PaintingYear   *int32          `db:"painting_year" json:"painting_year"`
	WidthInches    pgtype.Numeric  `db:"width_inches" json:"width_inches"`
	HeightInches   pgtype.Numeric  `db:"height_inches" json:"height_inches"`
	PriceCents     int32           `db:"price_cents" json:"price_cents"`
	Paper          *bool           `db:"paper" json:"paper"`
	SortOrder      int32           `db:"sort_order" json:"sort_order"`
	Status         ArtworkStatus   `db:"status" json:"status"`
	Medium         ArtworkMedium   `db:"medium" json:"medium"`
	Category       ArtworkCategory `db:"category" json:"category"`
}

func (q *Queries) UpdateArtwork(ctx context.Context, arg UpdateArtworkParams) (Artwork, error) {
	row := q.db.QueryRow(ctx, updateArtwork,
		arg.ID,
		arg.Title,
		arg.PaintingNumber,
		arg.PaintingYear,
		arg.WidthInches,
		arg.HeightInches,
		arg.PriceCents,
		arg.Paper,
		arg.SortOrder,
		arg.Status,
		arg.Medium,
		arg.Category,
	)
	var i Artwork
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.PaintingNumber,
		&i.PaintingYear,
		&i.WidthInches,
		&i.HeightInches,
		&i.PriceCents,
		&i.Paper,
		&i.SortOrder,
		&i.SoldAt,
		&i.Status,
		&i.Medium,
		&i.Category,
		&i.CreatedAt,
		&i.OrderID,
	)
	return i, err
}

const updateArtworksAsPurchased = `-- name: UpdateArtworksAsPurchased :many
UPDATE artworks
SET status = 'sold',
    sold_at = current_timestamp,
    order_id = $2
WHERE id = ANY($1::uuid [])
RETURNING id, title, painting_number, painting_year, width_inches, height_inches, price_cents, paper, sort_order, sold_at, status, medium, category, created_at, order_id
`

type UpdateArtworksAsPurchasedParams struct {
	Column1 []uuid.UUID `db:"column_1" json:"column_1"`
	OrderID pgtype.UUID `db:"order_id" json:"order_id"`
}

func (q *Queries) UpdateArtworksAsPurchased(ctx context.Context, arg UpdateArtworksAsPurchasedParams) ([]Artwork, error) {
	rows, err := q.db.Query(ctx, updateArtworksAsPurchased, arg.Column1, arg.OrderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Artwork
	for rows.Next() {
		var i Artwork
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.PaintingNumber,
			&i.PaintingYear,
			&i.WidthInches,
			&i.HeightInches,
			&i.PriceCents,
			&i.Paper,
			&i.SortOrder,
			&i.SoldAt,
			&i.Status,
			&i.Medium,
			&i.Category,
			&i.CreatedAt,
			&i.OrderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
